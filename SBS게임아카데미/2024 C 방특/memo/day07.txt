day07

1. 배열
- 하나의 이름으로 참조되는 같은 자료형을 갖는 메모리의 연속적인 공간

int a1, a2, ..., a100; <- 변수 여러 개 만들기 보다는
int a[100]; <- 100칸짜리 배열을 1개

리스트 		vs 	배열 
여러 자료형 가능		같은 자료형만
저장 용량 무제한		처음에 배열에 몇 개를 들어가게 할지
메모리가 불연속		연속

자료형 이름[크기];
c언어에서는 배열 크기에 변수 집어넣을 수 없다. 
c++에서는 가능
int a[10], char c[5];
배열이 메모리에서 차지하는 크기는 sizeof(자료형) * 지정한 크기

1) 배열 접근 (인덱싱)

인덱스 값을 사용해서 배열의 특정 위치에 있는 값을 가져온다
(인덱스 번호는 0부터 시작)

int a[3];
-> a라는 int형 3칸짜리 배열
  [0] [1] [2]  <-- 인덱스 번호
a  3   2   1

a[0] = 3; // a 배열에 인덱스 번호 0번에 3을 대입
a[1] = 2;
a[2] = 1;
a[3] = 0; // 주의 발생 (현재 배열의 크기가 3이기 때문)

a[0] -> 메모리 주소 100 번지
a[1] -> 104
a[2] -> 108
a[3] -> 112 // 컴파일러의 한계에 의해서 배열의 주소를 오버플로우


2) 배열의 선언과 초기화

int a = 2; char c = 'A';

선언과 함께 초기화
int a[5] = {1, 2, 3, 4, 5}; <- 배열을 나타내는 중괄호
int a[] = {1, 3, 5, 7, 9}; <- 크기가 정해지지 않은 배열
int a[5] = {1, 4}; <- 나머지는 쓰레기 값 또는 0으로 저장


2. 문자열
문자 + 배열(character array) -> 문자열(string)
문자: ''
문자열: ""

char 배열이름[배열크기] = {'문자1', '문자2', ...};
char 배열이름[] = "문자열";

1) 문자열 배열의 크기
문자열은 맨 뒤에 '\0'(null character) 가 있어야 지만 종료를 인식
배열의 크기를 지정할 때는 원래 문자열의 길이 + 1

2) 문자열 입출력
gets(fgets) puts
scanf printf -> %s

일반 문자 scanf("%c", &c);
문자열 scanf("%s", s);
문자열을 scanf로 받을 때에는 앞에 &(=주소)를 붙이지 않는다

배열들은 이름 자체가 주소


3. 배열과 함수

int a[5];

int f(int a[]); <- 함수 매개변수에 배열을 넣을 때 
함수의 매개변수로 배열을 넘길때에는 배열의 크기를 넣지 않음
-> sizeof를 이용해서 배열 전체의 크기를 알아내야 함
sizeof(배열) / sizeof(자료형)


4. 포인터 (pointer)
- Low 레벨 언어의 특징
- 메모리 주소를 가지고 직접 메모리의 내용에 접근하여 조작 할 수 있음
  (주소를 이용해서 값을 가리킨다)

1) 포인터의 선언
주소로 숫자기 때문에 일반적인 정수에 저장해도 되긴 함
-> 포인터를 위한 타입을 사용 (*)

int a = 10;
int* p = &a;  
int *p, int * p;

2) 포인터의 연산자
-> int* (간접 참조 연산자): int값을 가리키는 포인터 변수
-> *p (참조 연산자): 해당 주소의 값을 가리키는 변수
-> &a (역참조 연산자): a의 주소

3) 포인터의 크기
sizeof(int*), sizeof(double*), sizeof(void*)
무조건 8바이트 (64비트 VS설치할 때 기준), 4바이트 (32비트 VS설치할 때 기준)


5. 포인터와 배열

배열의 이름 = 주소 = 포인터로 쓸 수 있다
배열은 연속된 자료구조기 때문에 연속된 인덱스에 대해서 주소도 연속된다
자료형에 따라 달라짐 int(4), double(8)

전부 같은것을 가리키는 표현
a[0], *&a[0], *a, *&*a

1) 포인터 연산

포인터 변수, 값을 메모리 주소를 가지고 있음 -> 연산이 가능
포인터 연산은 덧셈과 뺄셈만 가능
덧셈 -> 메모리 주소 +
뺄셈 -> 메모리 주소 -

++, --를 했을 때 1씩 변하는 것이 아니라 원본 자료형의 크기만큼 변한다
(int* -> 4씩 변화, double* -> 8씩 변화)

우선순위: () > 증감 > 포인터

*p++ -> 포인터 이동
(*p)++ -> 현재 값을 1 더한다
*++p -> 포인터 이동
++*p -> 현재 값을 1 더한다


2) 포인터 배열
- 포인터가 들어있는 배열 (주소값이 들어있는 배열)
int a = 1, b = 2, c = 3;

int* p[3] = {&a, &b, &c};

-> 문자열 배열에서 사용
char *q[3] = {"hello", "java", "python};






