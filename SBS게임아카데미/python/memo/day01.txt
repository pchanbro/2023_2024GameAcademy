day01

1.OT
김류빈 강사, sbsrbkim@gmail.com
	(제목 : 파이썬 박찬형 )으로 보내기
	본문 : 코드의 전부, 오류 발생한 스크린샷 포함

구글 클래스룸
크롬 -> 구글 로그인 -> 구글 클래스룸 검색해서 들어가기 -> 오른쪽 위의 + 누르기
수업 코드 : nx7vv4o

2. 파이썬 

활용 용도가 많다

- 프론트엔드 -> 웹페이지에서 사용자에게 보이는 부분
  웹을 만들 수 있음

- 백엔드 -> 사용자에게 보이지 않는 부분
  서버 구성 가능

- 데이터 -> 사용자의 접속, 행동, 서버에 대한 통계, 인공지능
  파이썬, R언어의 인공지능 모듈/패키지

- 인프라 -> 서버를 다룸
  프론트 + 백엔드

- QA(품질) -> 만든 서비스 점검
  테스팅 툴을 만들 수 있음

코딩 테스트
C , C++, Java, Python, JavaScript 등

3. 프로그래밍 언어

컴퓨터에게 일을 시키려면 프로그램(컴퓨터가 수행할 명령어의 집합)이 필요

프로그래밍 언어란 이 프로그램을 작성하기 위한 툴

객체지향 : object 객체마다 구현을 해서 기능 위주로 구현하는 언어

절차지향 : 순서에 따라, 코드의 작성 순서에 따라 실행되는 언어

파이썬은 객체지향 이면서, 스크립트 언어이다.
미리 코드를 작성하고 코드의 위에서부터 실행하다가 중간에 오류가 발생하면 종료

프로그래밍 언어 스크립트(우리가 작성하는 코드) -(컴파일러) -> 기계어(컴퓨터가 이해할 수 있는 언어)

4. 파이썬 설치 방법
https://www.python.org/ => donwload -> python3.12.1
설치 시 add python.exe to PATH 반드시 체크 하기

윈도우+R -> cmd -> 확인 -> python입력 시 python 3.12.1이 나오면 정상

5. 파이썬의 특징
코드를 입력하면 입력한대로 바로바로 결과를 볼 수 있음 -> 생산성이 뛰어나다
-> 인터프리터 언어

파이썬 쉘 환경에서는 >>> 뒤에 명령어 입력 후 엔터를 누르면 즉시 명령 실행

6. 파이썬의 IDE(Integrated Development Environment : 통합 개발 환경)
IDLE SHELL은 파이썬을 위한 전문 IDE이기 때문에 파이썬코드에 대해서 도움말이나 안내가 상세함

IDLE Shell의 File 메뉴 -> New File -> 스크립트 모드 
스크립트 모드에서는 여러 줄의 코드를 쓴 후 한 번에 실행할 수 있음

스크립트 모드의 실행
1) Ctrl + S 저장
2) F5(Run > Run Module 실행)

쉘 모드는 코드 1개 단위로 실행을 하기 때문에 print 없이 출력할 수 있음
스크립트 모드는 코드 전체를 해석해서 실행하기 때문에 출력하기 위해서는 print가 반드시 필요

7. 변수(variable)
변수는 값을 저장하는 공간
a = 1
변수이름 = 값 -> 변수에 값을 할당 -> 즉시 변수 생성

변수에 저장된 값은 언제든지 변할 수 있다.
a = 1 -> a에 1 할당
print(a) -> 1출력
a = 2 -> a에 1을 지우고 2 할당
print(a) -> 2출력

a = 3.14 (실수 할당 가능)

a = "Hello" (문자 할당 가능)

a = 1+2j (복소수 할당 가능)

a = 10
b = 20
c = a + b -> 변수에는 연산을 통해 다른 변수의 값 할당 가능

8. 입력

입력을 받고자 할 때는 input함수를 사용

a = input()
input 함수에서 사용자의 입력을 대기 -> 엔터 입력 시 대기 종료(다른 키는 영향을 주지 않음)

input 함수의 괄호 안에 특정 문자열을 입력하면 안내 문구를 띄어주는 기능 -> input pormpt 입력 프롬프트

input 함수를 사용하면 입력 내용이 숫자든 영어든 한글이든 모두 문자로 처리
10 - > 문자 1과 문자 0
여기서
num1 = input("수1을 입력하세요 >>> ")
num2 = input("수2를 입력하세요 >>> ")
print(num1 + num2)
를 실행하고 num1 에 10을 입력,  num2에 20을 입력하면
1020이 출력됨

문자로 입력받았기 때문에 연결되어 출력한다.

수로 취급하고 싶다면
num1 = int(num1)
num2 = int(num2)를 추가하여

input 함수를 통해 입력받은 값을 정수로 사용할 때 사용하는 함수인 int함수로 num1, num2를 정수로 바꿔준다

실수 형태로 받고 싶다면 float 함수(floating point, 부동 소수점)를 사용한다.

a,b = input().split()
split()을 이용하여 한 줄에 공백으로 구분하여 두 개의 값을 입력한다

a,b = input().split()
3 5 
하면 
input() 의 결과로 3 5
split() 의 결과 a에는 "3", b에는 "5"가 


num1,num2 = input("두 수를 입력하세요 >>> ").split()
num1 = int(num1)
num2 = int(num2)
print(num1 + num2)

이렇게 값을 출력할 수도 있는데 
매번 int, float등의 함수로 형변환을 시켜주기 귀찮을 수 있다 그럴때
map 함수를 사용
num1,num2 = map(int,input().split())
map을 사용하여 여러 번 int함수를 사용하지 않고 수를 int형으로 만들어준다.

split함수의 괄호 안에 들어가는 것
-> 비어있으면 공백으로 구분해라
-> 비어있지 않으면 괄호안에 들어있는 특정 문자로 구분하기

a,b = input().split("!")
Hello!Python
하면 !을 기준으로 구분되어 a 에 Hello, b에 Python이 들어간다.

a,b,c = map(int, input("두 줄로 작성하며 세 수를 콤마(,)로 구분하고 더해라").split(","))
-10,20,60
하면 a에 -10 b에 20 c에 60이 들어간다

8. 출력(print)

출력 할 때 값을 콤마로 구분하여 출력하면 공백으로 구분되어 출력된다.
print(1, 2, 3)
-> 1 2 3 
print("Hello", "Python")
-> Hello Python

sep 속성 (separator)
-> 콤마를 이용해서 출력을 할 때 구분자가 띄어쓰기가 아니라 다른 문자로 바꾸고 싶다(여러 문자로 구분 가능) 
print(1,2,3, sep = ",")
-> 1,2,3 

print(1,2,3, sep = ", ")
-> 1, 2, 3

print(1,2,3, sep ="")
-> 123

print(1,2,3, sep = "\n") (\n은 줄을 바꿔 출력해준다) 
->1
2
3

\(백슬래시)가 붙은 문자들을 제어문자(escape character)라고 부른다

print(1,2,3, sep = "\t") (\t은 tap(띄워쓰기 8칸))
->1	2	3
	
print(1,2,3, sep = "\\") (백슬래시 사용하고 싶으면 \\로 해라)
->1\2\3\

print(1,2,3, sep = "\"") (큰따옴표 사용 시에도 제어문자(\)를 사용해야 한다)
->1"2"3
근데 큰따옴표 출력에는 제어문자 이용하지 않고 작은따옴표를 이용할 수도 있다
print(1,2,3, sep = '"')
->1"2"3

마찬가지로 작은따옴표 출력을 원할 때는 반대로 
print(1,2,3, sep = '\'')
->1'2'3'
print(1,2,3, sep = "'")
->1'2'3
이렇게 하면 된다.

여러개 사용해도 된다.
print(1,2,3, sep = "\"\n")
->1"
2"
3

end 사용하기

print 함수는 기본적으로 출력의 끝이 줄바꿈(\n)

print(1,end="")
print(2,end="")
print(3)
-> 123
end 자리에 "" 빈 문자열을 지정하면 원본 값인 \n(줄바꿈) 대신에 ""(빈 문자열)이 들어가
print를 했을 때 줄바꿈 안됨

a = 100
b = 200
c = 300
print(a, b, c, sep = "&", end = "!")
-> 100&200&300!
이렇게 sep과 end 동시에 사용 가능

9. 자료형 (data type)
type(~~) -> 자료형을 알 수 있음
파이썬에는 크게 3가지 자료형이 있다 

숫자형 
- 정수형 -> int
- 실수형 -> float
- 복소수형 -> complex
문자형 -> str
논리형 -> bool
(클래스형)

정수형(int) : 0, 양의정수, 음의정수
연산은  +, -, *, /(나눗셈), //(몫을 구하는 연산), %(나머지를 구하는 연산), **(거듭제곱)
몫과 나머지는 divmod 함수를 통해 구할 수도 있다.
a,b = divmod(5,2) -> a = 2, b = 1

int(정수) -> 정수 그대로 나옴
int(실수) -> 실수부 제외 정수부만 나옴
int(복소수) -> 오류 발생
int(문자열) -> 이 때 문자열이 숫자로만 이루어져 있다면 정수로 변환
	  -> 문자열이 정수 형태가 아니면 오류 발생
int(True) -> 1
int(False) -> 0

정수의 진수 변환
보통 10진수를 사용 이걸 2진수, 8진수, 16진수로 변환하기 반대로 2,8,16을 10진수로 변환하기
컴퓨터는 2진수 사용

2진수(0,1)
0b 리터럴 +(0,1) 숫자들

2진수 -> 10진수
0b1101
-> 13
1 * (2^0) = 1
0 * (2^1) = 0
1 * (2^2) = 4
1 * (2^3) = 8
1 + 0 + 4 + 8 = 13
int("1101",2)
-> 13
int(1101,2)는 오류

10진수 -> 2진수
bin(13)
->  1101
13 / 2 = 6 ..1
6 / 2 = 3.. 0
3 / 2 = 1.. 1 몫부터 거꾸로 읽으면 1101

8진수 octal
0o + (0~7)

8진수 -> 10진수
0o173
int("173", 8)
3 * (8^0) = 3 * 1 = 3
7 * (8^1) = 7 * 8 = 56
1 * (8^2) = 1 * 64 = 64
3 + 56 + 64 = 123

10진수 -> 8진수
oct(123)
123 / 8 = 15... 3
15/ 8 = 1... 7 거꾸로 읽으면 173

16진수 hexadecimal
0x + (0~9, A~F) A -> 10, B -> 11, ..., F -> 15

16진수 -> 10진수
0x1EB
int("1EB", 16)
B(11) * (16^0) = 11 * 1 = 11
E(14) * (16^1) = 14 * 16 = 224
1 * (16^2) = 1 * 256 = 256
11 + 224 + 256 = 491

10진수 -> 16진수
hex(491)
491 / 16 = 30 .. 11
30 / 16 =  1... 14
1, 14, 11 -> 1EB

실수 (float)
floating point, 부동 소수점(부유한다 할 때 부, 소수점이 떠서 움직인다.)
부동 소수점의 연산에 의해 매우 작은 오차가 발생한다.
3.14 - 2.71
-> 0.43000000000000016
이 오차는 10^-17 단위로 매우 작기 때문에 무시해도 된다.
무시 못하겠으면 반올림 하기
-> round(값, 소수점 몇자리까지 표시할 지) 
round(3.14 - 2.71,2)
->0.43

단, 파이썬에서의 반올림은 좀 특이하다  (오사오입 방식)
round(1.45,1) 올리는 수의 앞자리가 짝수면 5일 때 내림
->1.4
round(1.46,1)
->1.5
round(1.54,1)
->1.5
round(1.55,1) 올리는 수의 앞자리가 홀수면 5일 때 올림
->1.6

float(정수) -> 정수에 +0.0 실수부 붙어서 나옴
float(실수) -> 0
float(복소수) -> 오류 발생
float(문자열) -> 실수 형태의 문자열 0
	        정수 형태의 문자열 0(정수는 실수에 포함이니까)
float(True) -> 1.0
float(Float) -> 0.0

논리형 (boolean)

True(참), False(거짓)

논리형은 주로 비교 연산자의 결과로 나타나게 됨
> , < , >=, <=, ==, != (보통 =가 다른 기호 뒤에 있다는거 유의하기)

3 > 1 -> True
3 < 1 - > False
10 >= 4 -> True
5 <= 5 -> True
10 == 10 -> True
10 != 10 -> False

"Python" == "C++" -> False
"Python" == "Python" -> True
"Python" == "python" -> False

==을 통해 비교하게 되면 값만 같으면 같다
1 == 1.0 -> True
1 == 1+0j -> True
2.0 == 2+0j -> True

참고로 무시할 수 있을 정도의 오차가 포함되어도 True가 될 수 있다
1 == 1.000000000000000001 -> True
-> 부동소수점에 대한 오차는 무시가 됨
0.999999999999999999999 ==1 -> True
1.0000000000000001 == 1.0000000000000002 -> True