day01


1. OT
김류빈 강사, sbsrbkim@gmail.com
        제목: 파이썬 홍길동입니다.
        본문: 코드의 전부, 오류가 발생한 스크린샷


구글 클래스룸
크롬 -> 구글 로그인 -> 구글 클래스룸 -> 오른쪽 위 +
수업 코드: nx7vv4o




2. 파이썬의 진로


파이썬 -> 활용 용도가 무궁무진


개발자
- 프론트엔드 -> 웹페이지에서 사용자에게 보이는 부분
  파이썬을 통해서 웹을 만들 수 있음
- 백엔드 -> 사용자에게 보이지 않는 부분
  서버를 구성할 수 있음
- 데이터 -> 사용자의 접속, 행동, 서버에 대한 통계, 인공지능
  파이썬, R언어의 인공지능 모듈/패키지
- 인프라 -> 서버를 실제로 다루는 사람들
  프론트+백엔드
- QA(품질) -> 만든 서비스가 잘 돌아가냐
  파이썬을 통한 테스팅 툴


코딩 테스트 -> C, C++, Java, Python, JavaScript




3. 프로그래밍 언어


컴퓨터에게 일을 시키려면 프로그램(= 컴퓨터가 수행할 명령어의 집합)이 필요
-> 프로그램을 작성하기 위한 툴이 프로그래밍 언어


""객체지향 프로그래밍 언어"" : Object 객체마다 구현을 해서 기능 위주로 구현하는 언어
vs 
절차지향 프로그래밍 언어 : 순서가 있음 -> 코드의 작성 순서에 따라서 실행되는 언어


파이썬 = 객체지향 + 스크립트 언어 -> 미리 코드를 작성하고 코드의 위에서부터 실행하다가 중간에 오류가 발생하면 종료


print("Hello")
프로그래밍 언어 스크립트 -(컴파일러)-> 기계어




4. 파이썬 설치 방법


https://www.python.org/ -> Downloads -> Python 3.12.1 버전
설치 하실 때 첫 창에 나오는 Add python.exe to PATH를 "반드시" 체크 해주어야 함 -> Install Now


윈도우+R -> cmd -> 확인 -> python을 입력했을 땓 Python 3.12.1이 나오면 정상




5. 파이썬의 특징
코드를 입력하면 입력한대로 바로바로 결과를 볼 수 있음 -> 생산성이 뛰어나다
-> 인터프리터 언어


파이썬 쉘 환경에서는 >>> 뒤에 명령어를 입력하고 엔터를 누르면 즉시 명령이 실행된다




6. 파이썬의 IDE(Integrated Development Environment; 통합 개발 환경)
IDLE Shell은 파이썬을 위한 전문 IDE이기 때문에 파이썬 코드에 대해서 도움말이나 안내가 상세함
-> 쉘 모드


IDLE Shell의 File 메뉴 -> New File -> 스크립트 모드
스크립트 모드에서는 여러 줄의 코드를 쓴 후 한 번에 실행할 수 있음


스크립트 모드의 실행
1) Ctrl+S 저장한다
2) F5 (Run > Run Module 선택을 해 실행)


쉘 모드는 코드 1개 단위로 실행을 하기 때문에 print 없이 출력할 수 있음
스크립트 모드는 코드 전체를 해석해서 실행하기 때문에 출력하기 위해서는 print가 반드시 필요




7. 변수 (variable)


변수는 값을 저장하는 공간
a = 1
변수이름 = 값 -> 변수에 값을 할당한다 -> 그 즉시 변수가 생성이 됨


변수에 저장된 값은 언제든지 변할 수 있음
a = 1 -> a에 1 할당
print(a) -> 1이 출력
a = 2 -> 1이 지워지고 2 재할당
print(a) -> 2가 출력


a = 3.14 -> a에 3.14 할당
print(a)


a = "Hello" -> a에 "Hello" 문자 할당
print(a)


a = 1+2j -> 변수에 복소수도 할당할 수 있음
print(a)


a = 10
b = 20
c = a + b -> 변수에는 (연산을 통해서) 다른 변수의 값도 할당 가능


width = 10
height = 20
area = width * height
print(area)




8. 입력 (input)


입력을 받고자 할 때에는 input 함수를 사용합니다


a = input()
input 함수에서 사용자의 입력을 대기 -> 엔터를 입력하면 대기 종료
** 띄어쓰기를 쓰든, 다른 특수문자를 쓰든 무조건 엔터 입력에만 대기 종료 **


input 함수의 괄호 안에 특정 문자열을 입력하면 안내 문구를 띄어주는 기능 -> input prompt 입력 프롬프트


input 함수를 사용하면 입력한 내용이 숫자든 영어든 한글이든 무조건 문자로 처리됨
10 -> 문자 1과 문자 0
20 -> 문자 2와 문자 0
num1 + num2 -> 1020 (두개의 문자열이 연결되었다)


num1 = int(num1)
num2 = int(num2)


input 함수를 통해 입력받은 값을 정수로 바꿀 때 사용하는 함수 => int 함수 (integer)


num1 = float(num1)
num2 = float(num2)


정수가 아니라 실수 형태의 문자열을 입력 받았다
이 문자열을 실수로 바꾸기 위해 사용하는 함수 => float 함수 (floating point, 부동 소수점)




a, b = input().split()
한 줄에 공백으로 구분하여 두 개의 값을 입력할 경우
split() 함수를 이용해서 값을 잘라준다


input()의 결과 "3 5"
split()을 하면 "3"과 "5"가 됨
a에는 "3", b에는 "5"가 들어감






num1, num2 = map(int, input().split())
map 을 사용하여 여러 번 int 함수를 사용할 필요 없이 한 번에 int 로 변경할 수 있다.




split 함수의 괄호 안에 들어 가는 것
-> 비어있으면 공백으로 구분해라
-> 비어있지 않다면 특정 문자로 구분해라




입력: -10,20,50
출력: 60




8. 출력 (print)


출력 할 때 값을 콤마로 구분하여 출력하면 공백으로 구분되어 출력된다
print(1, 2, 3)
-> 1 2 3
print("Hello","Python")
-> Hello Python




sep 속성 (separator)
-> 콤마를 이용해서 출력을 할 때 구분자가 띄어쓰기가 아니라 다른 문자로 바꾸고 싶다!


print(1, 2, 3, sep=",")
-> 출력할 때 값들 사이에 띄어쓰기가 아니라 ,를 집어넣어라 -> 1,2,3


print(1, 2, 3, sep="")
-> sep에 빈 문자열을 지정하면 각 갑싱 서로 붙어서 출력된다 -> 123


print(1, 2, 3, sep="\n")
-> sep에 \n (백슬래시n)을 지정하면 줄바꿈이 되어서 출력된다


\(백슬래시)가 붙은 문자들 -> 제어 문자 (escape character)


print(1, 2, 3, sep="\t")
-> \t는 tab -> 일반적으로 띄어쓰기 8칸의 공간을 가짐


print(1, 2, 3, sep="\\")
-> 백슬래시 1개를 넣고 싶다 -> 백슬래시 2개를 써주어야 1개가 나오게 된다
-> 백슬래시는 제어 문자임을 나타내는 특수 문자기 때문에


print(1, 2, 3, sep="\"")
-> 큰 따옴표를 출력하고 싶다 -> 백슬래시+큰따옴표를 해야 오류 발생하지 않음
print(1, 2, 3, sep='"')
-> 작은 따옴표 안에 큰 따옴표를 넣어도 된다 (백슬래시 필요X)


print(1, 2, 3, sep='\'')
print(1, 2, 3, sep="'")
-> 작은 따옴표를 출력하고 싶은 경우


                   v    v <- 문자열 임을 표시하는 큰 따옴표 
print(1, 2, 3, sep="\"\n")
                    --    <- 큰따옴표를 출력하기 위해 사용한 백슬래시+큰따옴표
                      ~~  <- 줄바꿈을 출력하기 위해 사용한 백슬래시+n


print(1, 2, 3, sep='"\n')
                     ~~   <- 줄바꿈을 출력하기 위해 사용한 백슬래시+n
1"
2"
3




end 사용하기


print 함수는 기본적으로 출력의 끝이 줄바꿈(\n)


print(1, end="")
print(2, end="")
print(3)


end 자리에 "" 빈 문자열을 지정하면 원본 값인 \n(줄바꿈) 대신에 ""(빈 문자열)이 들어가 
print를 했을 때 줄바꿈 안됨


a = 100
b = 200
c = 300
print(a, b, c, sep="&", end="!")
-> 100&200&300!
sep과 end를 동시에 사용할 수 있음




9. 자료형 (data type)
type(~~) -> 자료형을 알 수 있음


숫자형
- 정수형 -> int
- 실수형 -> float
- 복소수형 -> complex
문자형 -> str
논리형 -> bool
(클래스형)




정수(int) = 자연수, 0, 음의 정수
+, -, *, /
// -> 몫
% -> 나머지
** -> 거듭제곱 


a, b = divmod(5, 2) -> 몫과 나머지를 한 번에 구할 수 있다.
print(a, b)


int(정수) -> 정수 그대로 나옴
int(실수) -> 실수부를 제외한 정수부만 나옴
int(복소수) -> 오류 발생
int(문자열) -> 이 때 문자열이 숫자로만 이루어져 있다면 정수로 변환
           -> 문자열이 정수 형태가 아니면 오류 발생
int(True) -> 1
int(False) -> 0




정수 진수 변환
사람이 사용한 진수는 10진수 (0~9까지 총 10개를 사용해서)
10진수 -> 2진수, 8진수, 16진수
2진수, 8진수, 16진수 -> 10진수




2진수 (0, 1) (binary)
0b 리터럴 + (0, 1) 숫자들


2진수 -> 10진수
0b1101
int("1101", 2)
1 * (2^0) = 1 * 1 = 1
0 * (2^1) = 0 * 2 = 0
1 * (2^2) = 1 * 4 = 4
1 * (2^3) = 1 * 8 = 8
1 + 0 + 4 + 8 = 13


10진수 -> 2진수
bin(13)
13 / 2 = 6 .. 1
6 / 2 = 3 ... 0
3 / 2 = 1 ... 1
거꾸로 읽으면 1101




8진수 octal
0o + (0~7)


8진수 -> 10진수
0o173
int("173", 8)
3 * (8^0) = 3 * 1 = 3
7 * (8^1) = 7 * 8 = 56
1 * (8^2) = 1 * 64 = 64
3 + 56 + 64 = 123


10진수 -> 8진수
oct(123)
123 / 8 = 15 .. 3
15 / 8 =  1 ... 7
거꾸로 읽으면 173




16진수 hexadecimal
0x + (0~9, A~F) A -> 10, B -> 11, ..., F -> 15


16진수 -> 10진수
0x1EB
int("1EB", 16)
B(11) * (16^0) = 11 * 1 = 11
E(14) * (16^1) = 14 * 16 = 224
1     * (16^2) = 1 * 256 = 256
11 + 224 + 256 = 491


10진수 -> 16진수
hex(491)
491 / 16 = 30 .. 11
30 / 16  = 1 ... 14
1, 14, 11 -> 1EB




실수 (float)
floating point, 부동 소수점 = 소수점이 떠서 움직인다
부동 소수점의 연산에 의해서 오차가 발생
이 발생한 오차는 10^-17 단위로 매우 작기 때문에 무시해도 될 정도의 오차
-> 반올림을 통해서 오차를 버릴 수 있음
-> round(값, 소수점 몇자리까지 표시할 지)


파이썬에서의 반올림 (오사오입 방식)
round(1.45, 1) -> 내가 짝수면 5일 때 내림
1.4
round(1.55, 1) -> 내가 홀수면 5일 때 올림
1.6




float(정수) -> 정수에 + 0.0 실수부 붙어서 나옴
float(실수) -> O
float(복소수) -> 오류 발생
float(문자열) -> 실수 형태의 문자열 O
                정수 형태의 문자열 O (정수 ⊂ 실수)
float(True) -> 1.0
float(False) -> 0.0






논리형 (boolean)


True(참), False(거짓)


논리형은 주로 비교 연산자의 결과로 나타나게 됨
>, <, >=, <=, ==, !=
**이상, 이하 기호에서는 =이 뒤에 나옴**


3 > 1 -> True
3 < 1 -> False
10 >= 4 -> True
5 <= 5 -> True
10 == 10 -> True
10 != 10 -> False


"Python" == "C++" -> False
"Python" == "Python" -> True
"Python" == "python" -> False


1 == 1.0 -> True
1 == 1+0j -> True
2.0 == 2+0j -> True


== 을 통해서 비교하게 되면 값만 같으면 같다


1 == 1.000000000000000000001 -> True
1.000000000000000000001 == 1.000000000000000000002 -> True
0.999999999999999999999 == 1 -> True
-> 부동소수점에 대한 오차는 무시가 됨